import * as Utils from './utils';

describe('closing windows and removing tabs', async () => {

	test('closing a focused window, when there are others', async () => {

		// given two windows
		const br = Utils.createFakeBrowserController([
			{ id: 111, tabs: 2 },
			{ id: 222, tabs: 1 }
		]);
		const callback = jest.fn();
		br.addEventListener(callback);

		// when closing one of them
		await br.closeWindow(111);

		// expect only the other window in the list
		const windows = await br.getAllWindows();
		expect(windows).toHaveLength(1);
		expect(windows.filter(win => win.id === 111)).toHaveLength(0);
		expect(windows.filter(win => win.id === 222)).toHaveLength(1);

		// expect the event handler to have been called
		// once for each tab, and one time for the window
		Utils.expectEvents(callback, [
			'onTabClosed',
			'onTabClosed',
			'onFocusChanged',
			'onWindowClosed'
		]);

	});

	test('closing a window with 4 tabs', async () => {

		// given two windows, one with window with 4 tabs
		const br = Utils.createFakeBrowserController([
			{ id: 111, tabs: 4 },
			{ id: 222, tabs: 0 }
		]);
		const callback = jest.fn();
		br.addEventListener(callback);

		// when closing the window with 4 tabs
		await br.closeWindow(111);

		// expect the event handler to have been called
		// once for each tab, and one time for the window
		Utils.expectEvents(callback, [
			'onTabClosed',
			'onTabClosed',
			'onTabClosed',
			'onTabClosed',
			'onFocusChanged',
			'onWindowClosed'
		]);
	});

	test('close the last tab in a window', async () => {

		// given a window with one existing tab		
		const br = Utils.createFakeBrowserController([{ id: 111, tabs: 1 }]);
		const onlyTabId = br.fakeGetWindows()[0].tabs[0].id;
		const callback = jest.fn();
		br.addEventListener(callback);

		// when removing the only tab
		await br.closeTab(onlyTabId);

		// expect the window to be gone
		const windows = await br.getAllWindows();
		expect(windows).toHaveLength(0);

		// also expect some events for the tab and window being closed
		Utils.expectEvents(callback, [
			'onTabClosed',		// chrome.tabs.onRemoved
			'onFocusChanged',	// chrome.windows.onFocusChanged
			'onWindowClosed'	// chrome.windows.onRemoved
		]);
		
	});

	test('close the active tab in a window with more than 1 tab', async () => {

		// given a window with 2 tabs
		const br = Utils.createFakeBrowserController([{ id: 111, tabs: 2 }]);
		const tabs = br.fakeGetWindows()[0].tabs;
		const tab0id = tabs[0].id;
		const tab1id = tabs[1].id;

		const callback = jest.fn();
		br.addEventListener(callback);

		// when removing one the active 
		await br.closeTab(tab0id);

		// expect the window to contain only one tab
		const windows = await br.getAllWindows();
		expect(windows).toHaveLength(1);
		expect(windows[0].tabs).toHaveLength(1);
		expect(windows[0].tabs.filter(t => t.id === tab0id)).toHaveLength(0);
		expect(windows[0].tabs.filter(t => t.id === tab1id)).toHaveLength(1);

		// also expect two events
		Utils.expectEvents(callback, ['onTabClosed', 'onTabSelected']);

	});

	test('close a non-active tab in a window with more than 1 tab', async () => {

		// given a window with 2 tabs
		const br = Utils.createFakeBrowserController([{ id: 111, tabs: 2 }]);
		const tabs = br.fakeGetWindows()[0].tabs;
		const tab0id = tabs[0].id;
		const tab1id = tabs[1].id;

		const callback = jest.fn();
		br.addEventListener(callback);

		// when removing one the inactive
		await br.closeTab(tab1id);

		// expect the window to contain only one tab
		const windows = await br.getAllWindows();
		expect(windows).toHaveLength(1);
		expect(windows[0].tabs).toHaveLength(1);
		expect(windows[0].tabs.filter(t => t.id === tab0id)).toHaveLength(1);
		expect(windows[0].tabs.filter(t => t.id === tab1id)).toHaveLength(0);

		// also expect one event
		Utils.expectEvents(callback, ['onTabClosed']);

	});
});